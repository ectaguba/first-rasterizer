{"ast":null,"code":"var _jsxFileName = \"/Users/christaguba/repos/first-rasterizer/src/components/Canvas.tsx\";\nimport React from \"react\";\nimport Pixel from \"./Pixel.tsx\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Canvas = ({\n  width,\n  height,\n  pixelSize\n}) => {\n  // Generate canvas grid of Pixel components\n  const generateCanvas = () => {\n    const pixels = [];\n    for (let x = 0; x < width; x++) {\n      for (let y = 0; y < height; y++) {\n        let pixelColor = (x + y) % 2 ? \"black\" : \"white\";\n        pixels.push( /*#__PURE__*/_jsxDEV(Pixel, {\n          x: x,\n          y: y,\n          color: pixelColor,\n          size: pixelSize\n        }, `${x}-${y}`, false, {\n          fileName: _jsxFileName,\n          lineNumber: 19,\n          columnNumber: 21\n        }, this));\n      }\n    }\n    return pixels;\n  };\n\n  // const putPixel(x: number, y: number, color: string, size: number): void = () => {\n  //     // for actually drawing in the pixel\n  // }\n\n  // const interpolate = (i0: number, d0: number, i1: number, d1: number): number[] => {\n  //     if (i0 == i1) {\n  //         return [d0];\n  //     }\n\n  //     let values[] = [];\n  //     const a = (d1 - d0) / (i1 - i0);\n  //     let d = d0;\n\n  //     for (let i = i0; i < i1; i++) {\n  //         values.push(d);\n  //         d += a;\n  //     }\n\n  //     return values;\n  // }\n\n  // const drawLine = (p0: Pixel, p1: Pixel, color: string): void => {\n  //     // for calculating slope\n  //     const dx = p1.x - p0.x;\n  //     const dy = p1.y - p0.y;\n  //     if (Math.abs(p1.x - p0.x) > Math.abs(p1.y - p0.y)) {\n  //         // line is horizontal-ish\n  //         if (p0.x > p1.x) {\n  //             [p0, p1] = [p1, p0]\n  //         }\n  //         let ys: number[] = interpolate(p0.x, p0.y, p1.x, p1.y);\n  //         for (let x = p0.x; x < p1.x; x++) {\n  //             canvas.putPixel(x, ys[x - p0.x], color);\n  //         }\n  //     } else {\n  //         // line is vertical-ish\n  //         if (p0.y > p1.y) {\n  //             [p0, p1] = [p1, p0]\n  //         }\n  //         let xs: number[] = interpolate(p0.y, p0.x, p1.y, p1.x);\n  //         for (let y = p0.y; y < p1.y; y++) {\n  //             canvas.putPixel(xs[y - p0.y], y, color);\n  //         }\n  //     }\n  // }\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      display: \"grid\",\n      width: `${width}px`,\n      height: {\n        height\n      },\n      gridTemplateColumns: `repeat(${width}, ${pixelSize}px)`,\n      gridTemplateRows: `repeat(${height}, ${pixelSize}px)`\n    },\n    children: generateCanvas()\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 79,\n    columnNumber: 9\n  }, this);\n};\n_c = Canvas;\nexport default Canvas;\nvar _c;\n$RefreshReg$(_c, \"Canvas\");","map":{"version":3,"names":["React","Pixel","jsxDEV","_jsxDEV","Canvas","width","height","pixelSize","generateCanvas","pixels","x","y","pixelColor","push","color","size","fileName","_jsxFileName","lineNumber","columnNumber","style","display","gridTemplateColumns","gridTemplateRows","children","_c","$RefreshReg$"],"sources":["/Users/christaguba/repos/first-rasterizer/src/components/Canvas.tsx"],"sourcesContent":["import React from \"react\";\n\nimport Pixel from \"./Pixel.tsx\";\n\ninterface CanvasProps {\n    width: number;\n    height: number;\n    pixelSize: number;\n}\n\nconst Canvas: React.FC<CanvasProps> = ({ width, height, pixelSize }) => {\n    // Generate canvas grid of Pixel components\n    const generateCanvas = (): JSX.Element[] => {\n        const pixels: JSX.Element[] = [];\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                let pixelColor = ((x+y) % 2) ? \"black\" : \"white\"\n                pixels.push(\n                    <Pixel \n                        key={`${x}-${y}`} \n                        x={x} \n                        y={y} \n                        color={pixelColor} \n                        size={pixelSize} \n                    />\n                );\n            }\n        }\n        return pixels;\n    };\n\n    // const putPixel(x: number, y: number, color: string, size: number): void = () => {\n    //     // for actually drawing in the pixel\n    // }\n\n    // const interpolate = (i0: number, d0: number, i1: number, d1: number): number[] => {\n    //     if (i0 == i1) {\n    //         return [d0];\n    //     }\n\n    //     let values[] = [];\n    //     const a = (d1 - d0) / (i1 - i0);\n    //     let d = d0;\n\n    //     for (let i = i0; i < i1; i++) {\n    //         values.push(d);\n    //         d += a;\n    //     }\n\n    //     return values;\n    // }\n\n    // const drawLine = (p0: Pixel, p1: Pixel, color: string): void => {\n    //     // for calculating slope\n    //     const dx = p1.x - p0.x;\n    //     const dy = p1.y - p0.y;\n    //     if (Math.abs(p1.x - p0.x) > Math.abs(p1.y - p0.y)) {\n    //         // line is horizontal-ish\n    //         if (p0.x > p1.x) {\n    //             [p0, p1] = [p1, p0]\n    //         }\n    //         let ys: number[] = interpolate(p0.x, p0.y, p1.x, p1.y);\n    //         for (let x = p0.x; x < p1.x; x++) {\n    //             canvas.putPixel(x, ys[x - p0.x], color);\n    //         }\n    //     } else {\n    //         // line is vertical-ish\n    //         if (p0.y > p1.y) {\n    //             [p0, p1] = [p1, p0]\n    //         }\n    //         let xs: number[] = interpolate(p0.y, p0.x, p1.y, p1.x);\n    //         for (let y = p0.y; y < p1.y; y++) {\n    //             canvas.putPixel(xs[y - p0.y], y, color);\n    //         }\n    //     }\n    // }\n\n    return (\n        <div\n          style={{\n            display: \"grid\",\n            width: `${width}px`,\n            height: {height},\n            gridTemplateColumns: `repeat(${width}, ${pixelSize}px)`,\n            gridTemplateRows: `repeat(${height}, ${pixelSize}px)`,\n          }}\n        >\n          {generateCanvas()}\n        </div>\n    );\n}\n\nexport default Canvas;"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,OAAOC,KAAK,MAAM,aAAa;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAQhC,MAAMC,MAA6B,GAAGA,CAAC;EAAEC,KAAK;EAAEC,MAAM;EAAEC;AAAU,CAAC,KAAK;EACpE;EACA,MAAMC,cAAc,GAAGA,CAAA,KAAqB;IACxC,MAAMC,MAAqB,GAAG,EAAE;IAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,EAAEK,CAAC,EAAE,EAAE;MAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,EAAEK,CAAC,EAAE,EAAE;QAC7B,IAAIC,UAAU,GAAI,CAACF,CAAC,GAACC,CAAC,IAAI,CAAC,GAAI,OAAO,GAAG,OAAO;QAChDF,MAAM,CAACI,IAAI,eACPV,OAAA,CAACF,KAAK;UAEFS,CAAC,EAAEA,CAAE;UACLC,CAAC,EAAEA,CAAE;UACLG,KAAK,EAAEF,UAAW;UAClBG,IAAI,EAAER;QAAU,GAJV,GAAEG,CAAE,IAAGC,CAAE,EAAC;UAAAK,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAKnB,CACL,CAAC;MACL;IACJ;IACA,OAAOV,MAAM;EACjB,CAAC;;EAED;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,oBACIN,OAAA;IACEiB,KAAK,EAAE;MACLC,OAAO,EAAE,MAAM;MACfhB,KAAK,EAAG,GAAEA,KAAM,IAAG;MACnBC,MAAM,EAAE;QAACA;MAAM,CAAC;MAChBgB,mBAAmB,EAAG,UAASjB,KAAM,KAAIE,SAAU,KAAI;MACvDgB,gBAAgB,EAAG,UAASjB,MAAO,KAAIC,SAAU;IACnD,CAAE;IAAAiB,QAAA,EAEDhB,cAAc,CAAC;EAAC;IAAAQ,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACd,CAAC;AAEd,CAAC;AAAAM,EAAA,GAhFKrB,MAA6B;AAkFnC,eAAeA,MAAM;AAAC,IAAAqB,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}